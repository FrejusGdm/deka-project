Deka — what it is
You’re building Deka, an open-source “translation meta-router.”

One REST endpoint (/translate) sits in front of every major engine—Google, DeepL, the smaller African-language providers (Vulavula, Step ES, etc.).
A canonical language map (ISO-639-1/3) hides all the mismatched provider codes, so callers can just say "Yoruba" (or "yo").
Optional /compare returns side-by-side results, latency, and raw cost for each provider so developers can pick the best output.
Usage is prepaid: users top-up a wallet; each call burns characters × provider price × 1.10. No credit ⇒ request is rejected, so you never float someone else’s bill.
Keys, quotas, and per-call analytics are handled by Unkey; spend aggregation by a lightweight meter (OpenMeter/Lago).
The FastAPI backend is containerized; you’ll run the free tier of Fly.io / Cloudflare Workers until traffic grows.
Everything is Apache/MIT licensed on GitHub and documented via the autogenerated OpenAPI spec + Mintlify docs.
Why you’re building it
Remove friction for African languages. Commercial APIs keep adding Zulu, Hausa, Yoruba, etc.—but each uses its own codes and pricing. Deka normalizes that mess, letting devs ship multilingual apps faster.
Fair, transparent pricing. A simple “provider cost + 10 %” surcharge keeps the service self-sustaining without venture funding or hidden mark-ups.
Vendor freedom. By speaking both a clean JSON schema and an optional OpenAI-compatible interface, Deka lets users swap engines or add regional ones without rewriting their code.
Learning & portfolio. As a college junior you get hands-on experience with FastAPI, async adapters, prepaid billing flows, and modern DevEx tooling—while publishing a useful project the community can extend.
In short: Deka is the missing adapter layer that unifies language codes, compares engine quality, and makes pay-as-you-go translation painless—starting with the languages that need it most.